// Generated by CoffeeScript 1.7.1
(function() {
  var DOMCursor, EmptyDOMCursor, MutableDOMCursor, charRect, emptyDOMCursor, isCollapsed, reject, selectRange, stubbornCharRect, stubbornCharRectNext, stubbornCharRectPrev,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  (function() {
    var domCursor, domCursorForCaret, getOrgText;
    DOMCursor.prototype.filterOrg = function() {
      return this.addFilter(function(n) {
        return !n.hasAttribute('data-nonorg') || 'skip';
      });
    };
    domCursor = function(node, pos) {
      return new DOMCursor(node, pos).filterOrg();
    };
    getOrgText = function(node) {
      return domCursor(node.firstChild, 0).mutable().filterTextNodes().filterParent(node).getText();
    };
    return domCursorForCaret = function() {
      var n, parent, sel;
      sel = getSelection();
      parent = parentForNode(sel.focusNode);
      n = domCursor(sel.focusNode, sel.focusOffset).mutable().filterVisibleTextNodes().filterParent(parent).firstText();
      if (n.pos < n.node.length) {
        return n;
      } else {
        return n.next();
      }
    };
  });

  DOMCursor = (function() {
    function DOMCursor(node, pos, filter) {
      var _ref;
      this.node = node;
      this.pos = pos;
      this.pos = (_ref = this.pos) != null ? _ref : 0;
      this.filter = filter || function() {
        return true;
      };
      this.computeType();
    }

    DOMCursor.prototype.computeType = function() {
      this.type = !this.node ? 'empty' : this.node.nodeType === Node.TEXT_NODE ? 'text' : 'element';
      return this;
    };

    DOMCursor.prototype.newPos = function(node, pos) {
      return new DOMCursor(node, pos, this.filter);
    };

    DOMCursor.prototype.isEmpty = function() {
      return this.type === 'empty';
    };

    DOMCursor.prototype.setFilter = function(f) {
      return new DOMCursor(this.node, this.pos, f);
    };

    DOMCursor.prototype.addFilter = function(filt) {
      var oldFilt;
      oldFilt = this.filter;
      return this.setFilter(function(n) {
        var r1, r2, _ref, _ref1;
        return (((_ref = (r1 = oldFilt(n))) === 'quit' || _ref === 'skip') && r1) || (((_ref1 = (r2 = filt(n))) === 'quit' || _ref1 === 'skip') && r2) || (r1 && r2);
      });
    };

    DOMCursor.prototype.next = function(up) {
      var n, res, saved;
      saved = this.save();
      n = this.nodeAfter(up);
      while (!n.isEmpty()) {
        switch (res = this.filter(n)) {
          case 'skip':
            n = n.nodeAfter(true);
            continue;
          case 'quit':
            break;
          default:
            if (res) {
              return n;
            }
        }
        n = n.nodeAfter();
      }
      return this.restore(saved).emptyNext();
    };

    DOMCursor.prototype.prev = function(up) {
      var n, res, saved;
      saved = this.save();
      n = this.nodeBefore(up);
      while (!n.isEmpty()) {
        switch (res = this.filter(n)) {
          case 'skip':
            n = n.nodeBefore(true);
            continue;
          case 'quit':
            break;
          default:
            if (res) {
              return n;
            }
        }
        n = n.nodeBefore();
      }
      return this.restore(saved).emptyPrev();
    };

    DOMCursor.prototype.moveCaret = function(r) {
      if (!r) {
        r = document.createRange();
      }
      r.setStart(this.node, this.pos);
      r.collapse(true);
      selectRange(r);
      return this;
    };

    DOMCursor.prototype.firstText = function(backwards) {
      var n;
      n = this;
      while (!n.isEmpty() && n.type !== 'text') {
        n = (backwards ? n.prev() : n.next());
      }
      return n;
    };

    DOMCursor.prototype.countChars = function(node, pos) {
      var n, tot;
      tot = 0;
      while (!n.isEmpty() && n.node !== node) {
        if (n.type === 'text') {
          tot += n.node.length;
        }
        n = n.next();
      }
      if (n.isEmpty() || n.node !== node) {
        return -1;
      } else if (n.type === 'text') {
        return tot + pos;
      } else {
        return tot;
      }
    };

    DOMCursor.prototype.forwardChars = function(count, contain) {
      var n;
      n = this;
      while (!n.isEmpty() && 0 <= count) {
        if (n.type === 'text') {
          if (count < n.node.length) {
            if (count === 0 && contain) {
              n = n.prev();
              while (n.type !== 'text') {
                n = n.prev();
              }
              return n.newPos(n.node, n.node.length);
            } else {
              return n.newPos(n.node, count);
            }
          }
          count -= n.node.length;
        }
        n = n.next();
      }
      return n.emptyNext();
    };

    DOMCursor.prototype.hasAttribute = function(a) {
      var _ref;
      return ((_ref = this.node) != null ? _ref.nodeType : void 0) === Node.ELEMENT_NODE && this.node.hasAttribute(a);
    };

    DOMCursor.prototype.getAttribute = function(a) {
      var _ref;
      return ((_ref = this.node) != null ? _ref.nodeType : void 0) === Node.ELEMENT_NODE && this.node.getAttribute(a);
    };

    DOMCursor.prototype.filterTextNodes = function() {
      return this.addFilter(function(n) {
        return n.type === 'text';
      });
    };

    DOMCursor.prototype.filterVisibleTextNodes = function() {
      return this.filterTextNodes().addFilter(function(n) {
        return !isCollapsed(n.node);
      });
    };

    DOMCursor.prototype.filterParent = function(parent) {
      if (!parent) {
        return this.setFilter(function() {
          return 'quit';
        });
      } else {
        return this.addFilter(function(n) {
          return parent.contains(n.node) || 'quit';
        });
      }
    };

    DOMCursor.prototype.filterRange = function(startContainer, startOffset, endContainer, endOffset) {
      var r;
      if (startOffset == null) {
        if (startContainer instanceof Range) {
          r = startContainer;
          startContainer = r.startContainer;
          startOffset = r.startOffset;
          endContainer = r.endContainer;
          endOffset = r.endOffset;
        } else {
          return this;
        }
      }
      return this.addFilter(function(n) {
        var endPos, startPos, _ref;
        startPos = startContainer.compareDocumentPosition(n.node);
        return (startPos === 0 ? (startOffset <= (_ref = n.pos) && _ref <= endOffset) : startPos & Node.DOCUMENT_POSITION_FOLLOWING ? (endPos = endContainer.compareDocumentPosition(n.node), endPos === 0 ? n.pos <= endOffset : endPos & Node.DOCUMENT_POSITION_PRECEDING) : void 0) || 'quit';
      });
    };

    DOMCursor.prototype.getText = function() {
      var n, t;
      n = this.mutable().firstText();
      if (n.isEmpty()) {
        return '';
      } else {
        t = n.node.data.substring(n.pos);
        while (!n.next().isEmpty()) {
          if (n.type === 'text') {
            t += n.node.data.substring(n.pos);
          }
        }
        if (t.length) {
          while (n.type !== 'text') {
            n.prev();
          }
          n.pos = n.node.length;
          while (n.pos > 0 && reject(n.filter(n))) {
            n.pos--;
          }
          return t.substring(0, t.length - n.node.length + n.pos);
        } else {
          return '';
        }
      }
    };

    DOMCursor.prototype.isNL = function() {
      return this.type === 'text' && this.node.data[this.pos] === '\n';
    };

    DOMCursor.prototype.endsInNL = function() {
      return this.type === 'text' && this.node.data[this.node.length - 1] === '\n';
    };

    DOMCursor.prototype.moveToStart = function() {
      return this.newPos(this.node, 0);
    };

    DOMCursor.prototype.moveToNextStart = function() {
      return this.next().moveToStart();
    };

    DOMCursor.prototype.moveToEnd = function() {
      var end;
      end = this.node.length - (this.endsInNL() ? 1 : 0);
      return this.newPos(this.node, end);
    };

    DOMCursor.prototype.moveToPrevEnd = function() {
      return this.prev().moveToEnd();
    };

    DOMCursor.prototype.forwardLine = function(goalFunc) {
      var bottom, line, n, r;
      if (!goalFunc) {
        goalFunc = function() {
          return -1;
        };
      }
      r = this.charRect();
      bottom = r.bottom;
      line = 0;
      n = this;
      while (n = n.forwardChar()) {
        if (n.isEmpty()) {
          return n.backwardChar();
        }
        r = n.charRect();
        if (r.bottom !== bottom) {
          bottom = r.bottom;
          line++;
        }
        if (line === 1 && goalFunc(r.left) > -1) {
          return n;
        }
        if (line === 2) {
          return n.backwardChar();
        }
      }
    };

    DOMCursor.prototype.backwardLine = function(goalFunc) {
      var line, n, prevTop, r, top;
      if (!goalFunc) {
        goalFunc = function() {
          return -1;
        };
      }
      r = this.charRect();
      prevTop = top = r.top;
      line = 0;
      n = this;
      while (n = n.backwardChar()) {
        if (n.isEmpty()) {
          return n.forwardChar();
        }
        r = n.charRect();
        if (r.top !== top) {
          top = r.top;
          line++;
        }
        if (line === 1) {
          switch (goalFunc(r.left)) {
            case 0:
              return n;
            case -1:
              return (prevTop === top ? n.forwardChar() : n);
          }
        }
        if (line === 2) {
          return n.forwardChar();
        }
        prevTop = top;
      }
    };

    DOMCursor.prototype.forwardChar = function() {
      var bottom, left, n, r;
      r = stubbornCharRectNext(this.node, this.pos);
      left = r != null ? r.left : void 0;
      bottom = r != null ? r.bottom : void 0;
      n = this;
      while (n = (n.pos + 1 < n.node.length ? n.newPos(n.node, n.pos + 1) : n.next())) {
        if (n.isEmpty() || ((r = stubbornCharRectNext(n.node, n.pos)) && (left !== (r != null ? r.left : void 0) || bottom !== (r != null ? r.bottom : void 0)))) {
          return n;
        }
      }
    };

    DOMCursor.prototype.backwardChar = function() {
      var n, r;
      r = stubbornCharRectPrev(this.node, this.pos);
      n = this;
      while (r && (n = (n.pos > 0 ? n.newPos(n.node, n.pos - 1) : n.prev()))) {
        if (n.isEmpty() || n.moved(r)) {
          return n;
        }
      }
      return n;
    };

    DOMCursor.prototype.show = function(topRect) {
      var posRect, top;
      posRect = this.charRect();
      top = (topRect != null ? topRect.width : void 0) && topRect.top === 0 ? topRect.bottom : 0;
      if (posRect.bottom > window.innerHeight) {
        window.scrollBy(0, posRect.bottom - window.innerHeight);
      } else if (posRect.top < top) {
        window.scrollBy(0, posRect.top - top);
      }
      return this;
    };

    DOMCursor.prototype.immutable = function() {
      return this;
    };

    DOMCursor.prototype.withMutations = function(func) {
      return func(this.copy().mutable());
    };

    DOMCursor.prototype.mutable = function() {
      return new MutableDOMCursor(this.node, this.pos, this.filter);
    };

    DOMCursor.prototype.save = function() {
      return this;
    };

    DOMCursor.prototype.restore = function(n) {
      return n.immutable();
    };

    DOMCursor.prototype.copy = function() {
      return this;
    };

    DOMCursor.prototype.nodeAfter = function(up) {
      var node;
      node = this.node;
      while (node) {
        if (node.nodeType === Node.ELEMENT_NODE && !up && node.childNodes.length) {
          return this.newPos(node.childNodes[0], 0);
        } else if (node.nextSibling) {
          return this.newPos(node.nextSibling, 0);
        } else {
          up = true;
          node = node.parentNode;
        }
      }
      return this.emptyNext();
    };

    DOMCursor.prototype.emptyNext = function() {
      return {
        __proto__: emptyDOMCursor,
        filter: this.filter,
        prev: (function(_this) {
          return function(up) {
            if (up) {
              return _this.prev(up);
            } else {
              return _this;
            }
          };
        })(this),
        nodeBefore: (function(_this) {
          return function(up) {
            if (up) {
              return _this.nodeBefore(up);
            } else {
              return _this;
            }
          };
        })(this)
      };
    };

    DOMCursor.prototype.nodeBefore = function(up) {
      var newNode, node;
      node = this.node;
      while (node) {
        if (node.nodeType === Node.ELEMENT_NODE && !up && node.childNodes.length) {
          newNode = node.childNodes[node.childNodes.length - 1];
        } else if (node.previousSibling) {
          newNode = node.previousSibling;
        } else {
          up = true;
          node = node.parentNode;
          continue;
        }
        return this.newPos(newNode, newNode.length);
      }
      return this.emptyPrev();
    };

    DOMCursor.prototype.emptyPrev = function() {
      return {
        __proto__: emptyDOMCursor,
        filter: this.filter,
        next: (function(_this) {
          return function(up) {
            if (up) {
              return _this.next(up);
            } else {
              return _this;
            }
          };
        })(this),
        nodeAfter: (function(_this) {
          return function(up) {
            if (up) {
              return _this.nodeAfter(up);
            } else {
              return _this;
            }
          };
        })(this)
      };
    };

    DOMCursor.prototype.moved = function(rec) {
      var r2;
      return (this.node.length > this.pos) && (r2 = stubbornCharRectPrev(this.node, this.pos)) && (rec.top !== r2.top || rec.left !== r2.left);
    };

    DOMCursor.prototype.charRect = function(r, prev) {
      if (prev) {
        return stubbornCharRectPrev(this.node, this.pos, r) || stubbornCharRectNext(this.node, this.pos, r);
      } else {
        return stubbornCharRect(this.node, this.pos, r);
      }
    };

    return DOMCursor;

  })();

  EmptyDOMCursor = (function(_super) {
    __extends(EmptyDOMCursor, _super);

    function EmptyDOMCursor() {
      return EmptyDOMCursor.__super__.constructor.apply(this, arguments);
    }

    EmptyDOMCursor.prototype.moveCaret = function() {
      return this;
    };

    EmptyDOMCursor.prototype.show = function() {
      return this;
    };

    EmptyDOMCursor.prototype.nodeAfter = function() {
      return this;
    };

    EmptyDOMCursor.prototype.nodeBefore = function() {
      return this;
    };

    EmptyDOMCursor.prototype.next = function() {
      return this;
    };

    EmptyDOMCursor.prototype.prev = function() {
      return this;
    };

    return EmptyDOMCursor;

  })(DOMCursor);

  emptyDOMCursor = new EmptyDOMCursor();

  MutableDOMCursor = (function(_super) {
    __extends(MutableDOMCursor, _super);

    function MutableDOMCursor(node, pos, filter) {
      this.node = node;
      this.pos = pos;
      this.filter = filter;
      MutableDOMCursor.__super__.constructor.call(this, node, pos, filter);
    }

    MutableDOMCursor.prototype.setFilter = function(filter) {
      this.filter = filter;
      return this;
    };

    MutableDOMCursor.prototype.newPos = function(node, pos) {
      this.node = node;
      this.pos = pos;
      return this.computeType();
    };

    MutableDOMCursor.prototype.copy = function() {
      return new MutableDOMCursor(this.node, this.pos, this.filter);
    };

    MutableDOMCursor.prototype.mutable = function() {
      return this;
    };

    MutableDOMCursor.prototype.immutable = function() {
      return new DOMCursor(this.node, this.pos, this.filter);
    };

    MutableDOMCursor.prototype.save = function() {
      return new DOMCursor(this.node, this.pos, this.filter);
    };

    MutableDOMCursor.prototype.restore = function(np) {
      this.node = np.node;
      this.pos = np.pos;
      this.filter = np.filter;
      return this;
    };

    MutableDOMCursor.prototype.emptyPrev = function() {
      this.type = 'empty';
      this.next = function(up) {
        this.revertEmpty();
        if (up) {
          return this.next(up);
        } else {
          return this;
        }
      };
      this.nodeAfter = function(up) {
        this.computeType();
        if (up) {
          return this.nodeAfter(up);
        } else {
          return this;
        }
      };
      this.prev = function() {
        return this;
      };
      this.nodeBefore = function() {
        return this;
      };
      return this;
    };

    MutableDOMCursor.prototype.revertEmpty = function() {
      this.computeType();
      delete this.next;
      delete this.prev;
      delete this.nodeAfter;
      delete this.nodeBefore;
      return this;
    };

    MutableDOMCursor.prototype.emptyNext = function() {
      this.type = 'empty';
      this.prev = function(up) {
        this.revertEmpty();
        if (up) {
          return this.prev(up);
        } else {
          return this;
        }
      };
      this.nodeBefore = function(up) {
        this.computeType();
        if (up) {
          return this.nodeBefore(up);
        } else {
          return this;
        }
      };
      this.next = function() {
        return this;
      };
      this.nodeAfter = function() {
        return this;
      };
      return this;
    };

    return MutableDOMCursor;

  })(DOMCursor);

  isCollapsed = function(node) {
    var type;
    if (node) {
      type = node.nodeType;
      return type === 7 || type === 8 || (type === Node.TEXT_NODE && (node.data === '' || isCollapsed(node.parentNode))) || /^(script|style)$/i.test(node.nodeName) || (type === Node.ELEMENT_NODE && node.offsetHeight === 0);
    } else {
      return false;
    }
  };

  selectRange = function(r) {
    var sel;
    sel = getSelection();
    sel.removeAllRanges();
    return sel.addRange(r);
  };

  reject = function(filterResult) {
    return !filterResult || (filterResult === 'quit' || filterResult === 'skip');
  };

  stubbornCharRect = function(node, pos, r) {
    return stubbornCharRectNext(node, pos, r) || stubbornCharRectPrev(node, pos, r);
  };

  stubbornCharRectNext = function(node, pos, r) {
    var i, rec, _i, _ref;
    r = r || document.createRange();
    for (i = _i = pos, _ref = node.length; _i < _ref; i = _i += 1) {
      if (rec = charRect(node, i, r)) {
        return rec;
      }
    }
    return null;
  };

  stubbornCharRectPrev = function(node, pos, r) {
    var i, rec, _i;
    r = r || document.createRange();
    for (i = _i = pos; _i >= 0; i = _i += -1) {
      if (rec = charRect(node, i, r)) {
        return rec;
      }
    }
    return null;
  };

  charRect = function(node, pos, r) {
    r = r || document.createRange();
    r.setStart(node, pos);
    r.collapse(true);
    return _(r.getClientRects()).last();
  };

  DOMCursor.MutableDOMCursor = MutableDOMCursor;

  DOMCursor.emptyDOMCursor = emptyDOMCursor;

  DOMCursor.isCollapsed = isCollapsed;

  DOMCursor.selectRange = selectRange;

  this.DOMCursor = DOMCursor;

}).call(this);

//# sourceMappingURL=domCursor.map
